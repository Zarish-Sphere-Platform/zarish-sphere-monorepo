#!/usr/bin/env node

/**
 * Master Index Generator for Zarish Sphere SSOT
 * 
 * This script automatically generates a comprehensive index of all documentation,
 * code files, and resources in the repository. It maintains the SSOT principle by
 * ensuring the index is always up-to-date with the actual repository structure.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

const IGNORE_DIRS = [
  'node_modules',
  '.git',
  'dist',
  'build',
  '.next',
  'coverage',
  '.vscode',
  '.idea',
  '.DS_Store',
  'pnpm-lock.yaml',
];

const IGNORE_FILES = [
  '.gitignore',
  '.env',
  '.env.local',
  '.DS_Store',
  'package-lock.json',
  'pnpm-lock.yaml',
];

// FileEntry type definition
const FileEntry = {};
// @typedef {Object} FileEntry
// @property {string} path
// @property {'file' | 'directory'} type
// @property {number} [size]
// @property {FileEntry[]} [children]

function shouldIgnore(name) {
  return IGNORE_DIRS.includes(name) || IGNORE_FILES.includes(name);
}

function buildFileTree(dir, prefix = '') {
  const entries = [];
  
  try {
    const files = fs.readdirSync(dir);
    
    for (const file of files) {
      if (shouldIgnore(file)) continue;
      
      const fullPath = path.join(dir, file);
      const relativePath = path.relative(rootDir, fullPath);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        entries.push({
          path: relativePath,
          type: 'directory',
          children: buildFileTree(fullPath, prefix + '  '),
        });
      } else {
        entries.push({
          path: relativePath,
          type: 'file',
          size: stat.size,
        });
      }
    }
  } catch (error) {
    console.error(`Error reading directory ${dir}:`, error.message);
  }
  
  return entries;
}

function formatFileTree(entries, prefix = '') {
  let output = '';
  
  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    const isLast = i === entries.length - 1;
    const connector = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
    
    if (entry.type === 'directory') {
      output += `${prefix}${connector}üìÅ **${path.basename(entry.path)}/**\n`;
      if (entry.children && entry.children.length > 0) {
        const newPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
        output += formatFileTree(entry.children, newPrefix);
      }
    } else {
      const icon = getFileIcon(entry.path);
      output += `${prefix}${connector}${icon} ${path.basename(entry.path)}\n`;
    }
  }
  
  return output;
}

function getFileIcon(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  const icons = {
    '.md': 'üìÑ',
    '.ts': 'üî∑',
    '.tsx': '‚öõÔ∏è',
    '.js': 'üü®',
    '.jsx': '‚öõÔ∏è',
    '.json': 'üìã',
    '.yaml': '‚öôÔ∏è',
    '.yml': '‚öôÔ∏è',
    '.css': 'üé®',
    '.html': 'üåê',
    '.sql': 'üóÑÔ∏è',
    '.sh': 'üîß',
    '.mjs': 'üü®',
  };
  return icons[ext] || 'üìÑ';
}

function generateIndex() {
  console.log('üìö Generating Master Index...');
  
  const fileTree = buildFileTree(rootDir);
  const treeOutput = formatFileTree(fileTree);
  
  const timestamp = new Date().toISOString();
  const indexContent = `# Zarish Sphere - Master Index

**Last Updated:** ${timestamp}

> This index is automatically generated by the Master Index Generator script.
> It provides a comprehensive overview of all files, directories, and resources in the Zarish Sphere repository.

## Repository Structure

\`\`\`
${treeOutput}
\`\`\`

## Key Directories

### /apps
Contains all user-facing applications and microfrontends:
- **gui-builder** - The core GUI application for non-coders to build applications
- **app-builder** - Application scaffolding and configuration interface
- **docs-portal** - Auto-generated documentation site

### /services
Backend services and microservices:
- **api-gateway** - Main entry point for all API calls
- **ai-logic** - AI-powered services for block suggestions and code generation
- **data-service** - Database interaction and CRUD operations

### /packages
Shared libraries and utilities:
- **ui-components** - Reusable React components and design system
- **shared-types** - TypeScript types generated from schemas
- **utility-functions** - Common utility code

### /schemas
Definitive source for data contracts:
- **db.ts** - Drizzle ORM database schema (SSOT for database)
- **api.yaml** - OpenAPI specification (SSOT for API contracts)
- **json-validation** - JSON Schemas for runtime validation

### /docs
Documentation source files:
- **index.md** - Root documentation entry point
- **architecture.md** - Architecture and design documentation
- **TODO.md** - Project roadmap and task tracking

### /tools
Automation scripts and generators:
- **check-generated.sh** - PR-mode validation script
- **generate-index.mjs** - This Master Index Generator
- **todo-sync.mjs** - Auto TODO sync workflow

### /.github
CI/CD workflows and GitHub configuration:
- **workflows/ci.yml** - Main CI pipeline
- **workflows/pr-validate.yml** - PR validation workflow
- **workflows/gh-pages.yml** - GitHub Pages auto-publishing

## SSOT Principles

This repository follows the **Single Source of Truth (SSOT)** principle:

1. **Schemas are the source** - Database and API schemas in \`/schemas\` are the definitive source
2. **Code is generated** - All client/server code is generated from schemas
3. **Documentation is auto-generated** - This index and API docs are auto-generated
4. **PR validation enforces consistency** - All generated files must be committed before merge

## Getting Started

1. **Read the Architecture** - Start with \`docs/architecture.md\`
2. **Explore the Code** - Browse the \`/apps\` and \`/services\` directories
3. **Check the Schemas** - Review \`/schemas\` for data contracts
4. **Run the Builder** - Start the GUI builder with \`pnpm dev\`

## Contributing

When contributing to this repository:

1. Update the source files (code, schemas, or documentation)
2. Run \`pnpm run generate\` to regenerate all outputs
3. Commit all changes including generated files
4. Create a pull request - the PR validation will check SSOT integrity

---

*Generated by Zarish Sphere Master Index Generator*
`;

  const indexPath = path.join(rootDir, 'docs', 'INDEX.md');
  
  // Ensure docs directory exists
  if (!fs.existsSync(path.join(rootDir, 'docs'))) {
    fs.mkdirSync(path.join(rootDir, 'docs'), { recursive: true });
  }
  
  fs.writeFileSync(indexPath, indexContent, 'utf-8');
  console.log(`‚úÖ Index generated: ${indexPath}`);
  
  return indexPath;
}

// Run the generator
try {
  generateIndex();
  process.exit(0);
} catch (error) {
  console.error('‚ùå Error generating index:', error.message);
  process.exit(1);
}
